# -*- coding: utf-8 -*-
"""Crop_Recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aCh90-3zY6BxKmNty--onMum7q3mMpSA

# Crop Recommendation- Mahsul Önerisi
- N, P, K: Topraktaki azot, fosfor ve potasyum değerleri

- temperature: Sıcaklık (°C)

- humidity: Nem (%)

- ph: Toprağın pH değeri

- rainfall: Yağış miktarı (mm)

- label: Ekilebilecek mahsul (örn: "rice")
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, accuracy_score
import numpy as np
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, ConfusionMatrixDisplay
!pip install --quiet lazypredict
from lazypredict.Supervised import LazyClassifier
import seaborn as sns
import matplotlib.pyplot as plt
import joblib
import random
from IPython.display import display, Markdown
import warnings
warnings.filterwarnings('ignore')

file_path = '/content/Crop_recommendation.csv'
data = pd.read_csv(file_path)
data.head()

#Histogram
for col in data.drop('label', axis=1).columns.tolist():
    sns.histplot(data[col], kde=True)
    plt.title(f"Distribution of {col}")
    plt.show()

data['label'].unique()

import seaborn as sns
import matplotlib.pyplot as plt

palette = sns.color_palette("husl", len(data['label'].unique()))  # Renk paleti

# Scatter plot
sns.scatterplot(
    x='rainfall', y='humidity', data=data,
    style='label', hue='label', palette=palette
)
plt.show()

palette = sns.color_palette("husl", len(data['label'].unique()))
sns.pairplot(data, hue = 'label', palette=palette)

data['label'].value_counts()

plt.figure(figsize=(10, 6))
sns.heatmap(data.corr(numeric_only=True), annot=True)
plt.title('Correlation Heatmap')
plt.show()

data.isnull().sum()

data.describe()

label_encoder = LabelEncoder()
data['label'] = label_encoder.fit_transform(data['label'])
data

def evaluateLazyClassifiers(datas, features_for_classification):
    features = datas.drop(features_for_classification, axis = 1)
    targets = datas[features_for_classification]
    features_train, features_test, targets_train, targets_test = train_test_split(features, targets, test_size = 0.2, random_state = 42)

    lazyClassifier = LazyClassifier(verbose = 0, ignore_warnings = True, custom_metric = None)
    models, predictions = lazyClassifier.fit(features_train, features_test, targets_train, targets_test)
    return models, features_train, features_test, targets_train, targets_test

models, features_train, features_test, targets_train, targets_test = evaluateLazyClassifiers(data, ['label'])

models

LR_model = LogisticRegression()
LR_model.fit(features_train, targets_train)

targets_pred = LR_model.predict(features_test)

print("Accuracy:", accuracy_score(targets_test, targets_pred))
print("Classification Report:\n", classification_report(targets_test, targets_pred, target_names = label_encoder.classes_))

display = ConfusionMatrixDisplay(confusion_matrix = confusion_matrix(targets_test, targets_pred), display_labels = label_encoder.classes_)

display.plot(cmap = 'Blues')
plt.title("Confusion Matrix")
plt.xticks(rotation = 90)
plt.show()

"""**K-fold cross-validation**"""

cv_scores = cross_val_score(LogisticRegression(), features_test, targets_test, cv = 5)

print("Cross-Validation Scores:", cv_scores)
print("Mean CV Accuracy:", np.mean(cv_scores))

joblib.dump(LR_model, "LogisticRegression_model.pkl")
joblib.dump(label_encoder, "label_encoder.pkl")

model = joblib.load("LogisticRegression_model.pkl")
label_encoder = joblib.load("label_encoder.pkl")

"""**Generating Random Values ​​For Model Prediction**"""

def generate_random_values():
    N = round(random.uniform(0, 150), 5)
    P = round(random.uniform(0, 150), 5)
    K = round(random.uniform(0, 200), 5)
    temperature = round(random.uniform(0, 45), 5)
    humidity = round(random.uniform(15, 100), 5)
    ph = round(random.uniform(3, 10), 5)
    rainfall = round(random.uniform(20, 300), 5)

    return N, P, K, temperature, humidity, ph, rainfall

emoji_mapping = {
    'N': ('🌿', 'N (Nitrogen ratio)'),
    'P': ('⚡', 'P (Phosphorous ratio)'),
    'K': ('💧', 'K (Potassium ratio)'),
    'temperature': ('🌡️', '°C (Temperature in Celsius)'),
    'humidity': ('💧', '% (Humidity)'),
    'ph': ('🔬', 'pH (Soil pH value)'),
    'rainfall': ('🌧️', 'mm (Rainfall in mm)')
    }

def print_attributes(N, P, K, temperature, humidity, ph, rainfall):
    display(Markdown(f"{emoji_mapping['N'][0]} **Nitrogen**: *{N} {emoji_mapping['N'][1]}*"))
    display(Markdown(f"{emoji_mapping['P'][0]} **Phosphorous**: *{P} {emoji_mapping['P'][1]}*"))
    display(Markdown(f"{emoji_mapping['K'][0]} **Potassium**: *{K} {emoji_mapping['K'][1]}*"))
    display(Markdown(f"{emoji_mapping['temperature'][0]} **Temperature**: *{temperature} {emoji_mapping['temperature'][1]}*"))
    display(Markdown(f"{emoji_mapping['humidity'][0]} **Humidity**: *{humidity} {emoji_mapping['humidity'][1]}*"))
    display(Markdown(f"{emoji_mapping['ph'][0]} **pH**: {ph} *{emoji_mapping['ph'][1]}*"))
    display(Markdown(f"{emoji_mapping['rainfall'][0]} **Rainfall**: *{rainfall} {emoji_mapping['rainfall'][1]}*"))

crop_emoji_mapping = {
    'Rice': '🌾',
    'Maize (Corn)': '🌽',
    'Chickpea': '🫘',
    'Kidney Beans': '🫘',
    'Pigeon Peas': '🫘',
    'Moth Beans': '🫘',
    'Mung Bean': '🫘',
    'Black Gram': '🫘',
    'Lentil': '🫘',
    'Pomegranate': '🍎',
    'Banana': '🍌',
    'Mango': '🥭',
    'Grapes': '🍇',
    'Watermelon': '🍉',
    'Muskmelon': '🍈',
    'Apple': '🍎',
    'Orange': '🍊',
    'Papaya': '🥭',
    'Coconut': '🥥',
    'Cotton': '🌱',
    'Jute': '🪢',
    'Coffee': '☕'
}


def predict_crop(N, P, K, temperature, humidity, ph, rainfall):
    features = np.array([[N, P, K, temperature, humidity, ph, rainfall]])
    prediction = model.predict(features)
    crop_name = label_encoder.inverse_transform(prediction)[0]

    display(Markdown(f"The most suitable crop for agriculture in the given conditions is: {crop_emoji_mapping[crop_name]} **{crop_name}** {crop_emoji_mapping[crop_name]}."))

from IPython.display import display, Markdown

def crop_recommendation_pipeline(i):
    display(Markdown(f"### Crop Recommendation- {i + 1}"))
    N, P, K, temperature, humidity, ph, rainfall = generate_random_values()
    print_attributes(N, P, K, temperature, humidity, ph, rainfall)
    print()
    predict_crop(N, P, K, temperature, humidity, ph, rainfall)
    print()

for i in range(20):
    crop_recommendation_pipeline(i)

